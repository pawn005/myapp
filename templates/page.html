<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>{{ "{:03d}".format(page_id) }}</title>
<style>
body { margin:0; font-family:sans-serif; background:black; color:white; overflow:hidden; }
.header { display:flex; align-items:center; padding:10px; font-size:1.2em; cursor:pointer; }
#backBtn { color:white; margin-right:10px; }
canvas { display:block; margin:0 auto; background:black; }
textarea, button, input { font-family: sans-serif; }
</style>

<!-- TensorFlow.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>
</head>
<body>
<div class="header">
  <span id="backBtn">BACK</span>
  <span class="page-id">{{ "{:03d}".format(page_id) }}</span>
</div>

<canvas id="piCanvas"></canvas>
<canvas id="apiChart" style="display:none;"></canvas>

<script>
document.getElementById("backBtn").addEventListener("click", function() {
  window.location.href = "{{ url_for('index') }}";
});

const canvas = document.getElementById("piCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

{% if page_id == 0 %}
// 000ページ: 円周率アニメ
const centerX = canvas.width / 2;
const centerY = canvas.height / 2;
let step = 0;
const pi_digits = "14159265358979323846264338327950288419716939937510";

function drawPi() {
  ctx.fillStyle = "rgba(0,0,0,0.1)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const digit = parseInt(pi_digits[step]);
  const angle = digit * 36 * Math.PI / 180;
  const length = 200;

  const x = centerX + length * Math.cos(angle);
  const y = centerY + length * Math.sin(angle);

  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(centerX, centerY);
  ctx.lineTo(x, y);
  ctx.stroke();

  step = (step + 1) % pi_digits.length;
  requestAnimationFrame(drawPi);
}
drawPi();

{% elif page_id == 1 %}
// 001ページ: 模倣表示（単純な色ブロック）
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

const blockSize = 50;
let frame = 0;

function drawMock() {
  ctx.fillStyle = "rgba(0,0,0,0.2)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const cols = Math.floor(canvas.width / blockSize);
  const rows = Math.floor(canvas.height / blockSize);

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const hue = (frame + r*20 + c*10) % 360;
      ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
      ctx.fillRect(c*blockSize, r*blockSize, blockSize-2, blockSize-2);
    }
  }

  frame += 2;
  requestAnimationFrame(drawMock);
}
drawMock();

{% elif page_id == 2 %}
// 002ページ: ピラミッド
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

const blockSize2 = 40;
let frame2 = 0;
function drawPyramid() {
  ctx.fillStyle = "rgba(0,0,0,0.2)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const base = 10;
  const offsetX = canvas.width / 2;
  const offsetY = canvas.height - 50;
  const colorSeed = Math.floor(Date.now() / 100) % 360;

  for (let row = 0; row < base; row++) {
    for (let col = 0; col < base-row; col++) {
      if (frame2/5 >= row) {
        const hue = (colorSeed + row*40 + col*60) % 360;
        ctx.fillStyle = `hsl(${hue},80%,60%)`;
        const x = offsetX - (base-row)*blockSize2/2 + col*blockSize2;
        const y = offsetY - row*blockSize2;
        ctx.fillRect(x,y,blockSize2-2,blockSize2-2);
      }
    }
  }

  frame2++;
  if(frame2 > base*10) frame2=0;
  requestAnimationFrame(drawPyramid);
}
drawPyramid();

{% elif page_id == 3 %}
// 003ページ: リサジュー曲線
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

let t3 = 0;
function drawLissajous() {
  ctx.fillStyle = "rgba(0,0,0,0.05)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const A = 200;
  const B = 150;
  const a = 3;
  const b = 2;
  const delta = Math.PI/2;

  const x = canvas.width/2 + A * Math.sin(a * t3 + delta);
  const y = canvas.height/2 + B * Math.sin(b * t3);

  ctx.fillStyle = `hsl(${t3*50%360},80%,60%)`;
  ctx.beginPath();
  ctx.arc(x,y,5,0,Math.PI*2);
  ctx.fill();

  t3 += 0.02;
  requestAnimationFrame(drawLissajous);
}
drawLissajous();

{% elif page_id == 4 %}
// 004ページ: フラクタルツリー
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

function drawFractalTree(x1, y1, angle, depth) {
  if(depth === 0) return;
  const length = depth * 15;
  const x2 = x1 + Math.cos(angle) * length;
  const y2 = y1 + Math.sin(angle) * length;
  ctx.strokeStyle = `hsl(${depth*30%360},70%,60%)`;
  ctx.lineWidth = Math.max(depth,1);
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  drawFractalTree(x2, y2, angle - Math.PI/6, depth - 1);
  drawFractalTree(x2, y2, angle + Math.PI/6, depth - 1);
}

function animateTree() {
  ctx.fillStyle = "rgba(0,0,0,0.2)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  const baseX = canvas.width/2;
  const baseY = canvas.height - 50;
  const time = Date.now() / 1000;
  drawFractalTree(baseX, baseY, -Math.PI/2 + Math.sin(time)/4, 10);
  requestAnimationFrame(animateTree);
}
animateTree();

{% elif page_id == 5 %}
// 005ページ: 黄金比スパイラル
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

let t5 = 0;
function drawGoldenSpiral() {
  ctx.fillStyle = "rgba(0,0,0,0.05)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  const phi = (1 + Math.sqrt(5))/2;
  const centerX = canvas.width/2;
  const centerY = canvas.height/2;
  for(let i = 0; i < 200; i++) {
    const angle = i * 0.3 + t5;
    const radius = Math.pow(phi, i*0.05) * 5;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    ctx.fillStyle = `hsl(${i*5 + t5*50 % 360},80%,60%)`;
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI*2);
    ctx.fill();
  }
  t5 += 0.02;
  requestAnimationFrame(drawGoldenSpiral);
}
drawGoldenSpiral();

{% elif page_id == 6 %}
// 006ページ: Cat Fact
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

let x = canvas.width;
const y = canvas.height / 2;

function drawCatFact(catFact) {
  ctx.fillStyle = "rgba(0,0,0,0.1)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.fillStyle = "white";
  ctx.font = "24px sans-serif";
  ctx.fillText(catFact, x, y);
  
  x -= 2; // 左にスクロール
  if (x < -ctx.measureText(catFact).width) x = canvas.width;
  
  requestAnimationFrame(() => drawCatFact(catFact));
}

// fetch してから描画開始
fetch("https://catfact.ninja/fact")
  .then(res => res.json())
  .then(data => {
    drawCatFact(data.fact);
  })
  .catch(err => {
    drawCatFact("Failed to load cat fact.");
    console.error(err);
  });

{% elif page_id == 7 %}
// 007ページ: 反射で色が変わるボール
const balls = [];
const maxBalls = 16;

function createBall(x, y, vx, vy, radius) {
    balls.push({x, y, vx, vy, radius, colorHue: Math.random()*360});
}

function drawBalls() {
    ctx.fillStyle = "rgba(0,0,0,0.1)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const newBalls = [];
    for(let ball of balls) {
        ball.x += ball.vx;
        ball.y += ball.vy;
        if(ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
            ball.vx *= -1;
            ball.colorHue = Math.random()*360;
            if(balls.length + newBalls.length < maxBalls) {
                newBalls.push({x: ball.x, y: ball.y, vx: ball.vx*(Math.random()*0.4+0.8), vy: ball.vy*(Math.random()*0.4+0.8), radius: ball.radius, colorHue: Math.random()*360});
            }
        }
        if(ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
            ball.vy *= -1;
            ball.colorHue = Math.random()*360;
            if(balls.length + newBalls.length < maxBalls) {
                newBalls.push({x: ball.x, y: ball.y, vx: ball.vx*(Math.random()*0.4+0.8), vy: ball.vy*(Math.random()*0.4+0.8), radius: ball.radius, colorHue: Math.random()*360});
            }
        }
        ctx.fillStyle = `hsl(${ball.colorHue}, 80%, 60%)`;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
        ctx.fill();
    }

    balls.push(...newBalls);
    requestAnimationFrame(drawBalls);
}
createBall(canvas.width/2, canvas.height/2, 10, 10, 20);
drawBalls();

{% elif page_id == 8 %}
// 008ページ: AIによる文章要約
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

ctx.font = "24px sans-serif";
ctx.fillStyle = "white";
ctx.textAlign = "center";
ctx.fillText("AI要約ページ", canvas.width/2, 100);

const inputBox = document.createElement("textarea");
inputBox.style.position = "absolute";
inputBox.style.top = "150px";
inputBox.style.left = "50%";
inputBox.style.transform = "translateX(-50%)";
inputBox.style.width = "60%";
inputBox.style.height = "100px";
inputBox.style.fontSize = "16px";
inputBox.style.background = "rgba(255,255,255,0.1)";
inputBox.style.color = "white";
inputBox.style.border = "1px solid white";
inputBox.placeholder = "要約したい文章を入力してください";
document.body.appendChild(inputBox);

const sendBtn = document.createElement("button");
sendBtn.innerText = "AI要約";
sendBtn.style.position = "absolute";
sendBtn.style.top = "270px";
sendBtn.style.left = "50%";
sendBtn.style.transform = "translateX(-50%)";
sendBtn.style.padding = "10px 20px";
sendBtn.style.cursor = "pointer";
document.body.appendChild(sendBtn);

const resultArea = document.createElement("div");
resultArea.style.position = "absolute";
resultArea.style.top = "330px";
resultArea.style.left = "50%";
resultArea.style.transform = "translateX(-50%)";
resultArea.style.width = "60%";
resultArea.style.textAlign = "center";
resultArea.style.whiteSpace = "pre-wrap";
document.body.appendChild(resultArea);

sendBtn.addEventListener("click", async () => {
  const text = inputBox.value;
  if (!text) {
    resultArea.innerText = "テキストを入力してください。";
    return;
  }
  resultArea.innerText = "AIが要約中...";
  const res = await fetch("/summarize", {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({ text })
  });
  const data = await res.json();
  resultArea.innerText = data
  resultArea.innerText = data.summary || "要約できませんでした。";
});

{% elif page_id == 9 %}
// 009ページ: TensorFlow.jsで画像分類
canvas.style.display = "none";
document.getElementById("apiChart").style.display = "block";

const fileInput = document.createElement("input");
fileInput.type = "file";
fileInput.accept = "image/*";
fileInput.style.position = "absolute";
fileInput.style.top = "50px";
fileInput.style.left = "50%";
fileInput.style.transform = "translateX(-50%)";
document.body.appendChild(fileInput);

const imgPreview = document.createElement("img");
imgPreview.style.position = "absolute";
imgPreview.style.top = "100px";
imgPreview.style.left = "50%";
imgPreview.style.transform = "translateX(-50%)";
imgPreview.style.maxWidth = "300px";
document.body.appendChild(imgPreview);

const resultDiv = document.createElement("div");
resultDiv.style.position = "absolute";
resultDiv.style.top = "420px";
resultDiv.style.left = "50%";
resultDiv.style.transform = "translateX(-50%)";
resultDiv.style.color = "white";
document.body.appendChild(resultDiv);

let model;
mobilenet.load().then(m => { model = m; });

fileInput.addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    imgPreview.src = ev.target.result;
    imgPreview.onload = async function() {
      if (!model) {
        resultDiv.innerText = "モデル読み込み中…";
        return;
      }
      const predictions = await model.classify(imgPreview);
      resultDiv.innerText = predictions.map(p => `${p.className}: ${(p.probability*100).toFixed(2)}%`).join("\n");
    };
  };
  reader.readAsDataURL(file);
});

{% elif page_id == 10 %}
// 010ページ: APIグラフ描画
canvas.style.display = "none";
const chartCanvas = document.getElementById("apiChart");
chartCanvas.style.display = "block";
chartCanvas.width = window.innerWidth * 0.8;
chartCanvas.height = 400;
const chartCtx = chartCanvas.getContext("2d");

fetch("https://api.coindesk.com/v1/bpi/historical/close.json")
  .then(res => res.json())
  .then(data => {
    const prices = data.bpi;
    const keys = Object.keys(prices);
    const values = Object.values(prices);
    const maxPrice = Math.max(...values);
    const minPrice = Math.min(...values);
    
    chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
    chartCtx.strokeStyle = "lime";
    chartCtx.beginPath();
    for (let i = 0; i < values.length; i++) {
      const x = i * (chartCanvas.width / values.length);
      const y = chartCanvas.height - ((values[i] - minPrice) / (maxPrice - minPrice) * chartCanvas.height);
      if (i === 0) chartCtx.moveTo(x, y);
      else chartCtx.lineTo(x, y);
    }
    chartCtx.stroke();
  })
  .catch(err => {
    chartCtx.fillStyle = "white";
    chartCtx.fillText("API取得失敗", 50, 50);
    console.error(err);
  });

{% endif %}
</script> 
</body> 
</html>