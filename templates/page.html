<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>{{ "{:03d}".format(page_id) }}</title>
<style>
body { margin:0; font-family:sans-serif; background:black; color:white; }
.header { display:flex; align-items:center; padding:10px; font-size:1.2em; cursor:pointer; }
#backBtn { color:white; margin-right:10px; }
canvas { display:block; margin:0 auto; background:black; }
</style>
</head>
<body>
<div class="header">
  <span id="backBtn">BACK</span>
  <span class="page-id">{{ "{:03d}".format(page_id) }}</span>
</div>

<canvas id="piCanvas"></canvas>
<canvas id="apiChart" style="display:none;"></canvas>

<script>
document.getElementById("backBtn").addEventListener("click", function() {
  window.location.href = "{{ url_for('index') }}";
});

const canvas = document.getElementById("piCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

{% if page_id == 0 %}
// 000ページ: 円周率アニメ
const centerX = canvas.width / 2;
const centerY = canvas.height / 2;
let step = 0;
const pi_digits = "14159265358979323846264338327950288419716939937510";

function drawPi() {
  ctx.fillStyle = "rgba(0,0,0,0.1)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const digit = parseInt(pi_digits[step]);
  const angle = digit * 36 * Math.PI / 180;
  const length = 200;

  const x = centerX + length * Math.cos(angle);
  const y = centerY + length * Math.sin(angle);

  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(centerX, centerY);
  ctx.lineTo(x, y);
  ctx.stroke();

  step = (step + 1) % pi_digits.length;
  requestAnimationFrame(drawPi);
}
drawPi();

{% elif page_id == 1 %}
// 001ページ: 模倣表示（単純な色ブロック）
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

const blockSize = 50;
let frame = 0;

function drawMock() {
  ctx.fillStyle = "rgba(0,0,0,0.2)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const cols = Math.floor(canvas.width / blockSize);
  const rows = Math.floor(canvas.height / blockSize);

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const hue = (frame + r*20 + c*10) % 360;
      ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
      ctx.fillRect(c*blockSize, r*blockSize, blockSize-2, blockSize-2);
    }
  }

  frame += 2;
  requestAnimationFrame(drawMock);
}
drawMock();

{% elif page_id == 2 %}
// 002ページ: ピラミッド
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

const blockSize2 = 40;
let frame2 = 0;
function drawPyramid() {
  ctx.fillStyle = "rgba(0,0,0,0.2)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const base = 10;
  const offsetX = canvas.width / 2;
  const offsetY = canvas.height - 50;
  const colorSeed = Math.floor(Date.now() / 100) % 360;

  for (let row = 0; row < base; row++) {
    for (let col = 0; col < base-row; col++) {
      if (frame2/5 >= row) {
        const hue = (colorSeed + row*40 + col*60) % 360;
        ctx.fillStyle = `hsl(${hue},80%,60%)`;
        const x = offsetX - (base-row)*blockSize2/2 + col*blockSize2;
        const y = offsetY - row*blockSize2;
        ctx.fillRect(x,y,blockSize2-2,blockSize2-2);
      }
    }
  }

  frame2++;
  if(frame2 > base*10) frame2=0;
  requestAnimationFrame(drawPyramid);
}
drawPyramid();

{% elif page_id == 3 %}
// 003ページ: リサジュー曲線
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

let t3 = 0;
function drawLissajous() {
  ctx.fillStyle = "rgba(0,0,0,0.05)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const A = 200;
  const B = 150;
  const a = 3;
  const b = 2;
  const delta = Math.PI/2;

  const x = canvas.width/2 + A * Math.sin(a * t3 + delta);
  const y = canvas.height/2 + B * Math.sin(b * t3);

  ctx.fillStyle = `hsl(${t3*50%360},80%,60%)`;
  ctx.beginPath();
  ctx.arc(x,y,5,0,Math.PI*2);
  ctx.fill();

  t3 += 0.02;
  requestAnimationFrame(drawLissajous);
}
drawLissajous();

{% elif page_id == 4 %}
// 004ページ: フラクタルツリー
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

function drawFractalTree(x1, y1, angle, depth) {
  if(depth === 0) return;
  const length = depth * 15;
  const x2 = x1 + Math.cos(angle) * length;
  const y2 = y1 + Math.sin(angle) * length;
  ctx.strokeStyle = `hsl(${depth*30%360},70%,60%)`;
  ctx.lineWidth = Math.max(depth,1);
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  drawFractalTree(x2, y2, angle - Math.PI/6, depth - 1);
  drawFractalTree(x2, y2, angle + Math.PI/6, depth - 1);
}

function animateTree() {
  ctx.fillStyle = "rgba(0,0,0,0.2)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  const baseX = canvas.width/2;
  const baseY = canvas.height - 50;
  const time = Date.now() / 1000;
  drawFractalTree(baseX, baseY, -Math.PI/2 + Math.sin(time)/4, 10);
  requestAnimationFrame(animateTree);
}
animateTree();

{% elif page_id == 5 %}
// 005ページ: 黄金比スパイラル
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

let t5 = 0;
function drawGoldenSpiral() {
  ctx.fillStyle = "rgba(0,0,0,0.05)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  const phi = (1 + Math.sqrt(5))/2;
  const centerX = canvas.width/2;
  const centerY = canvas.height/2;
  for(let i = 0; i < 200; i++) {
    const angle = i * 0.3 + t5;
    const radius = Math.pow(phi, i*0.05) * 5;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    ctx.fillStyle = `hsl(${i*5 + t5*50 % 360},80%,60%)`;
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI*2);
    ctx.fill();
  }
  t5 += 0.02;
  requestAnimationFrame(drawGoldenSpiral);
}
drawGoldenSpiral();
{% elif page_id == 6 %}
// 006ページ: Cat Fact
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

let x = canvas.width;
const y = canvas.height / 2;

function drawCatFact(catFact) {
  ctx.fillStyle = "rgba(0,0,0,0.1)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.fillStyle = "white";
  ctx.font = "24px sans-serif";
  ctx.fillText(catFact, x, y);
  
  x -= 2; // 左にスクロール
  if (x < -ctx.measureText(catFact).width) x = canvas.width;
  
  requestAnimationFrame(() => drawCatFact(catFact));
}

// fetch してから描画開始
fetch("https://catfact.ninja/fact")
  .then(res => res.json())
  .then(data => {
    drawCatFact(data.fact);
  })
  .catch(err => {
    drawCatFact("Failed to load cat fact.");
    console.error(err);
  });
  {% elif page_id == 7 %}
// 007ページ: 反射で色が変わるボール（ボール上限16）
const balls = [];
const maxBalls = 16;

function createBall(x, y, vx, vy, radius) {
    balls.push({x, y, vx, vy, radius, colorHue: Math.random()*360});
}

function drawBalls() {
    ctx.fillStyle = "rgba(0,0,0,0.1)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const newBalls = [];
    for(let ball of balls) {
        ball.x += ball.vx;
        ball.y += ball.vy;

        // 反射チェック
        if(ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
            ball.vx *= -1;
            ball.colorHue = Math.random()*360;
            if(balls.length + newBalls.length < maxBalls) {
                // 反射時にボールを増やす（角度微妙に変化）
                newBalls.push({
                    x: ball.x,
                    y: ball.y,
                    vx: ball.vx * (Math.random()*0.4 + 0.8),
                    vy: ball.vy * (Math.random()*0.4 + 0.8),
                    radius: ball.radius,
                    colorHue: Math.random()*360
                });
            }
        }
        if(ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
            ball.vy *= -1;
            ball.colorHue = Math.random()*360;
            if(balls.length + newBalls.length < maxBalls) {
                newBalls.push({
                    x: ball.x,
                    y: ball.y,
                    vx: ball.vx * (Math.random()*0.4 + 0.8),
                    vy: ball.vy * (Math.random()*0.4 + 0.8),
                    radius: ball.radius,
                    colorHue: Math.random()*360
                });
            }
        }

        ctx.fillStyle = `hsl(${ball.colorHue}, 80%, 60%)`;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
        ctx.fill();
    }

    balls.push(...newBalls);

    requestAnimationFrame(drawBalls);
}

// 初期ボール作成
createBall(canvas.width/2, canvas.height/2, 10, 10, 20);
drawBalls();
{% elif page_id == 8 %}
/* 008ページ: AIによる文章要約デモ */

canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

ctx.font = "24px sans-serif";
ctx.fillStyle = "white";
ctx.textAlign = "center";
ctx.fillText("AI要約ページ", canvas.width/2, 100);

const inputBox = document.createElement("textarea");
inputBox.style.position = "absolute";
inputBox.style.top = "150px";
inputBox.style.left = "50%";
inputBox.style.transform = "translateX(-50%)";
inputBox.style.width = "60%";
inputBox.style.height = "100px";
inputBox.style.fontSize = "16px";
inputBox.style.background = "rgba(255,255,255,0.1)";
inputBox.style.color = "white";
inputBox.style.border = "1px solid white";
inputBox.placeholder = "要約したい文章を入力してください";
document.body.appendChild(inputBox);

const sendBtn = document.createElement("button");
sendBtn.innerText = "AI要約";
sendBtn.style.position = "absolute";
sendBtn.style.top = "270px";
sendBtn.style.left = "50%";
sendBtn.style.transform = "translateX(-50%)";
sendBtn.style.padding = "10px 20px";
sendBtn.style.cursor = "pointer";
document.body.appendChild(sendBtn);

const resultArea = document.createElement("div");
resultArea.style.position = "absolute";
resultArea.style.top = "330px";
resultArea.style.left = "50%";
resultArea.style.transform = "translateX(-50%)";
resultArea.style.width = "60%";
resultArea.style.textAlign = "center";
resultArea.style.whiteSpace = "pre-wrap";
document.body.appendChild(resultArea);

sendBtn.addEventListener("click", async () => {
  const text = inputBox.value;
  if (!text) {
    resultArea.innerText = "テキストを入力してください。";
    return;
  }

  resultArea.innerText = "AIが要約中...";
  const res = await fetch("/summarize", {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({ text })
  });
  const data = await res.json();
  resultArea.innerText = data.result;
});
{% elif page_id == 9 %}
// 009ページ: AI風ランダムアート
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

const particles = [];
const particleCount = 200;

// マウス位置追跡
let mouseX = canvas.width / 2;
let mouseY = canvas.height / 2;
canvas.addEventListener("mousemove", e => {
  mouseX = e.clientX;
  mouseY = e.clientY;
});

function createParticles() {
  for (let i = 0; i < particleCount; i++) {
    particles.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      vx: (Math.random() - 0.5) * 2,
      vy: (Math.random() - 0.5) * 2,
      hue: Math.random() * 360
    });
  }
}

function drawParticles() {
  ctx.fillStyle = "rgba(0,0,0,0.1)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  for (let p of particles) {
    // マウスに少し引き寄せられる
    let dx = mouseX - p.x;
    let dy = mouseY - p.y;
    p.vx += dx * 0.0005;
    p.vy += dy * 0.0005;
    
    p.x += p.vx;
    p.y += p.vy;
    
    // 画面端で跳ね返る
    if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
    if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
    
    // 描画
    ctx.fillStyle = `hsl(${p.hue}, 80%, 60%)`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // 色少し変化
    p.hue += 0.5;
  }
  
  requestAnimationFrame(drawParticles);
}

createParticles();
drawParticles();
{% elif page_id == 10 %}
// 010ページ: 写真判定（TensorFlow.js）
canvas.style.display = "block";
document.getElementById("apiChart").style.display = "none";

const imgInput = document.createElement("input");
imgInput.type = "file";
imgInput.accept = "image/*";
document.body.appendChild(imgInput);

let model;
(async () => {
  model = await mobilenet.load();
  console.log("モデル読み込み完了");
})();

imgInput.addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = evt => {
    const img = new Image();
    img.onload = async () => {
      // Canvas に描画
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
      const w = img.width * scale;
      const h = img.height * scale;
      ctx.drawImage(img, (canvas.width - w) / 2, (canvas.height - h) / 2, w, h);
      
      // AI 判定
      const predictions = await model.classify(img);
      ctx.fillStyle = "white";
      ctx.font = "20px sans-serif";
      ctx.fillText(`${predictions[0].className} (${(predictions[0].probability*100).toFixed(1)}%)`, 10, 30);
    };
    img.src = evt.target.result;
  };
  reader.readAsDataURL(file);
});
{% endif %}
</script>
</body>
</html>